{"project_token": "BgBwpXsqwk4HPUttHb/uSKUfNgjDzo5iKtLiQBQnPsA=", "functions": [{"id": "main.py:callback:11", "source_code": "def callback(ctx: typer.Context):\n    return default_callback(ctx)", "input": [{"id": "main.py:callback:11:arg:0", "argument_name": "ctx", "argument_type": "typer.Context"}], "output_type": null, "file": "main.py"}, {"id": "callback.py:callback:14", "source_code": "def callback(ctx: typer.Context):\n    \"\"\"\n    Default command: Extract functions from latest git commit\n    \"\"\"\n    # If a subcommand was invoked, don't run the default behavior\n    if ctx.invoked_subcommand is not None:\n        return\n\n    console.print(\"\ud83d\udd0d Checking for new functions in latest commit...\")\n\n    # Step 1: Check if clepon.toml exists\n    pwd = Path.cwd()\n    config_path = pwd / CONFIG_FILENAME\n\n    if not config_path.exists():\n        err_console.print(\n            f\"\u274c Error: {CONFIG_FILENAME} not found in current directory!\"\n        )\n        err_console.print(\"Please run 'clepon init' first to initialize the project.\")\n        raise typer.Exit(1)\n\n    # Step 2: Read token from toml file\n    try:\n        project_token = read_token_from_toml(config_path)\n        console.print(f\"\u2705 Found project token: {project_token[:20]}...\")\n    except Exception as e:\n        err_console.print(f\"\u274c Error reading token: {e}\")\n        raise typer.Exit(1)\n\n    # Step 3: Get git diff from latest commit\n    console.print(\"\ud83d\udcca Getting git diff from latest commit...\")\n    diff_output = get_git_diff()\n\n    if not diff_output:\n        err_console.print(\"\u2139\ufe0f  No changes found in latest commit\")\n        raise typer.Exit(0)\n\n    # Step 4: Extract functions from diff\n    console.print(\"\ud83d\udd0e Extracting functions from diff...\")\n    functions = parse_diff_output(diff_output)\n\n    if not functions:\n        err_console.print(\"\u2139\ufe0f  No new functions found in latest commit\")\n        raise typer.Exit(0)\n\n    console.print(f\"\u2705 Extracted {len(functions)} new/modified functions\")\n\n    # Step 5: Write output to JSON\n    project_data = Project(project_token=project_token, functions=functions)\n\n    output_path = pwd / \"diff_functions.json\"\n    with open(output_path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(project_data.model_dump(), f, indent=2)\n\n    console.print(f\"\u2705 Wrote output to {output_path}\")\n    console.print(\"\ud83c\udf89 Complete!\")", "input": [{"id": "callback.py:callback:14:arg:0", "argument_name": "ctx", "argument_type": "typer.Context"}], "output_type": null, "file": "callback.py"}, {"id": "init.py:init:22", "source_code": "def init():\n    \"\"\"Initialize the project and extract all Python functions\"\"\"\n    console.print(\"\ud83d\ude80 Initializing Clepon Function Extractor\")\n\n    # Step 1: Generate project token\n    project_token = generate_project_token()\n    console.print(f\"\u2705 Generated project token: {project_token[:20]}\")\n\n    # Step 2: Store token in TOML configuration\n    pwd = Path.cwd()\n    config_path = pwd / \"clepon.toml\"\n    store_token_in_toml(project_token, config_path)\n    console.print(f\"\u2705 Stored project token in {config_path}\")\n\n    # Step 3: Find all Python files in the current directory\n    python_files = find_python_files(pwd)\n    console.print(f\"\u2705 Found {len(python_files)} Python files\")\n\n    # Step 4: Extract function from all Python files\n    all_functions = []\n    for python_file in python_files:\n        console.print(f\"\ud83d\udcc4 Parsing {python_file.relative_to(pwd)}...\")\n        functions = parse_python_file(python_file)\n        all_functions.extend(functions)\n\n    console.print(f\"\u2705 Extracted {len(all_functions)} functions from all Python files\")\n\n    # Step 5: Create project data\n    project_data = Project(project_token=project_token, functions=all_functions)\n\n    # Step 6: Write to JSON file (for debugging for now instead of API call)\n    output_path = pwd / \"project_data.json\"\n    with open(output_path, \"w\", encoding=\"utf-8\") as json_file:\n        json.dump(project_data.model_dump(), json_file)\n\n    console.print(f\"\u2705 Project data written to {output_path}\")\n    console.print(\"\ud83c\udf89 Initialization complete!\")", "input": [], "output_type": null, "file": "init.py"}, {"id": "project_service.py:generate_project_token:17", "source_code": "def generate_project_token() -> str:\n    \"\"\"Generate a random base64 project token\"\"\"\n    random_bytes = secrets.token_bytes(32)\n    return base64.b64encode(random_bytes).decode(\"utf-8\")", "input": [], "output_type": "str", "file": "project_service.py"}, {"id": "project_service.py:store_token_in_toml:23", "source_code": "def store_token_in_toml(token: str, config_path: Path) -> None:\n    \"\"\"Store the project token in a TOML configuration\"\"\"\n    config = {\"project\": {\"token\": token}}\n    with open(config_path, \"w\") as config_file:\n        toml.dump(config, config_file)", "input": [{"id": "project_service.py:store_token_in_toml:23:arg:0", "argument_name": "token", "argument_type": "str"}, {"id": "project_service.py:store_token_in_toml:23:arg:1", "argument_name": "config_path", "argument_type": "Path"}], "output_type": "None", "file": "project_service.py"}, {"id": "project_service.py:read_token_from_toml:30", "source_code": "def read_token_from_toml(config_path: Path) -> str:\n    \"\"\"Read the project token from the .toml file\"\"\"\n    with open(config_path, \"r\") as f:\n        config = toml.load(f)\n    return config[\"project\"][\"token\"]", "input": [{"id": "project_service.py:read_token_from_toml:30:arg:0", "argument_name": "config_path", "argument_type": "Path"}], "output_type": "str", "file": "project_service.py"}, {"id": "project_service.py:find_python_files:37", "source_code": "def find_python_files(directory: Path) -> List[Path]:\n    files = directory.rglob(\"*.py\")\n    return [\n        f\n        for f in files\n        if not any(part.startswith(\".\") for part in f.relative_to(directory).parts)\n    ]", "input": [{"id": "project_service.py:find_python_files:37:arg:0", "argument_name": "directory", "argument_type": "Path"}], "output_type": "List[Path]", "file": "project_service.py"}, {"id": "project_service.py:extract_function_info_from_file:46", "source_code": "def extract_function_info_from_file(node: ast.FunctionDef, filepath: str) -> Function:\n    \"\"\"Extract function information from an AST node\"\"\"\n    # Generate unique identifier for the function\n    filename = Path(filepath).name\n\n    func_id = f\"{filename}:{node.name}:{node.lineno}\"\n\n    # Extract source code\n    source_lines = ast.get_source_segment(open(filepath).read(), node)\n    if source_lines is None:\n        # Fallback: try to reconstruct\n        source_lines = ast.unparse(node)\n\n    # Extract arguments\n    arguments = []\n    for i, arg in enumerate(node.args.args):\n        arg_type = None\n        if arg.annotation:\n            arg_type = ast.unparse(arg.annotation)\n\n        arguments.append(\n            FunctionArgument(\n                id=f\"{func_id}:arg:{i}\", argument_name=arg.arg, argument_type=arg_type\n            )\n        )\n\n    # Extract return type\n    output_type = None\n    if node.returns:\n        output_type = ast.unparse(node.returns)\n\n    return Function(\n        id=func_id,\n        source_code=source_lines,\n        input=arguments,\n        output_type=output_type,\n        file=filename,\n    )", "input": [{"id": "project_service.py:extract_function_info_from_file:46:arg:0", "argument_name": "node", "argument_type": "ast.FunctionDef"}, {"id": "project_service.py:extract_function_info_from_file:46:arg:1", "argument_name": "filepath", "argument_type": "str"}], "output_type": "Function", "file": "project_service.py"}, {"id": "project_service.py:parse_python_file:86", "source_code": "def parse_python_file(filepath: Path) -> List[Function]:\n    \"\"\"Parse a Python file and extract all function definitions\"\"\"\n    functions = []\n\n    try:\n        with open(filepath, \"r\", encoding=\"utf-8\") as file:\n            content = file.read()\n\n        tree = ast.parse(content, filename=str(filepath))\n\n        # Walk through all nodes in the AST\n        for node in ast.walk(tree):\n            if isinstance(node, ast.FunctionDef):\n                func_info = extract_function_info_from_file(node, str(filepath))\n                functions.append(func_info)\n\n    except Exception as e:\n        err_console.print(f\"[red]Error parsing {filepath}: {e}[/red]\")\n\n    return functions", "input": [{"id": "project_service.py:parse_python_file:86:arg:0", "argument_name": "filepath", "argument_type": "Path"}], "output_type": "List[Function]", "file": "project_service.py"}, {"id": "project_service.py:get_git_diff:108", "source_code": "def get_git_diff() -> str:\n    \"\"\"Get the git diff of the latest commit\"\"\"\n    # First check if we're in a git repository\n    try:\n        subprocess.run(\n            [\"git\", \"rev-parse\", \"--git-dir\"], capture_output=True, check=True\n        )\n    except subprocess.CalledProcessError:\n        console.print(\"\u274c Error: Not a git repository!\")\n        console.print(\"Please initialize git first: git init\")\n        raise typer.Exit(1)\n\n    # Check if there are any commits\n    try:\n        subprocess.run([\"git\", \"rev-parse\", \"HEAD\"], capture_output=True, check=True)\n    except subprocess.CalledProcessError:\n        console.print(\"\u274c Error: No commits found in repository!\")\n        console.print(\"Please make at least one commit first.\")\n        raise typer.Exit(1)\n\n    # Check if there's a previous commit (HEAD~1)\n    try:\n        subprocess.run([\"git\", \"rev-parse\", \"HEAD~1\"], capture_output=True, check=True)\n    except subprocess.CalledProcessError:\n        console.print(\"\u274c Error: Only one commit exists!\")\n        console.print(\"Please make at least one more commit to compare.\")\n        console.print(\"Alternatively, use 'git diff HEAD' to see uncommitted changes.\")\n        raise typer.Exit(1)\n\n    # Now get the actual diff\n    try:\n        result = subprocess.run(\n            [\"git\", \"diff\", \"HEAD~1\", \"HEAD\"],\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n        return result.stdout\n    except subprocess.CalledProcessError as e:\n        console.print(f\"\u274c Error running git diff: {e}\")\n        console.print(f\"stderr: {e.stderr if hasattr(e, 'stderr') else 'N/A'}\")\n        raise typer.Exit(1)", "input": [], "output_type": "str", "file": "project_service.py"}, {"id": "project_service.py:extract_function_info_from_diff:152", "source_code": "def extract_function_info_from_diff(\n    node: ast.FunctionDef, filepath: str, source_code: str\n) -> Function:\n    \"\"\"Extract function information from an AST node with provided source\"\"\"\n    # Generate unique ID\n    filename = Path(filepath).name\n\n    func_id = f\"{filename}:{node.name}:{node.lineno}\"\n\n    # Extract source code for this specific function\n    source_lines = ast.get_source_segment(source_code, node)\n    if source_lines is None:\n        source_lines = ast.unparse(node)\n\n    # Extract arguments\n    arguments = []\n    for i, arg in enumerate(node.args.args):\n        arg_type = None\n        if arg.annotation:\n            arg_type = ast.unparse(arg.annotation)\n\n        arguments.append(\n            FunctionArgument(\n                id=f\"{func_id}:arg:{i}\", argument_name=arg.arg, argument_type=arg_type\n            )\n        )\n    # Extract return type\n    output_type = None\n    if node.returns:\n        output_type = ast.unparse(node.returns)\n\n    return Function(\n        id=func_id,\n        source_code=source_lines,\n        input=arguments,\n        output_type=output_type,\n        file=filename,\n    )", "input": [{"id": "project_service.py:extract_function_info_from_diff:152:arg:0", "argument_name": "node", "argument_type": "ast.FunctionDef"}, {"id": "project_service.py:extract_function_info_from_diff:152:arg:1", "argument_name": "filepath", "argument_type": "str"}, {"id": "project_service.py:extract_function_info_from_diff:152:arg:2", "argument_name": "source_code", "argument_type": "str"}], "output_type": "Function", "file": "project_service.py"}, {"id": "project_service.py:parse_diff_output:192", "source_code": "def parse_diff_output(diff_output: str) -> List[Function]:\n    \"\"\"Extract function definitions from git diff output\"\"\"\n    functions = []\n\n    # Parse diff to find added Python code\n    lines = diff_output.split(\"\\n\")\n    current_file = None\n    added_code_blocks = []\n    current_block = []\n\n    for line in lines:\n        # Track which file we're looking at\n        if line.startswith(\"+++ b/\"):\n            current_file = line[6:]\n            if not current_file.endswith(\".py\"):\n                current_file = None\n\n        # Collect added lines (lines starting with +)\n        elif line.startswith(\"+\") and not line.startswith(\"+++\") and current_file:\n            # Remove the + prefix\n            code_line = line[1:]\n            current_block.append(code_line)\n\n        # When we hit a non-added line, process the accumulated block\n        elif current_block and current_file:\n            added_code_blocks.append((current_file, \"\\n\".join(current_block)))\n            current_block = []\n\n    # Don't forget the last block\n    if current_block and current_file:\n        added_code_blocks.append((current_file, \"\\n\".join(current_block)))\n\n    # Extract functions from added code blocks\n    for filepath, code_block in added_code_blocks:\n        try:\n            tree = ast.parse(code_block)\n            for node in ast.walk(tree):\n                if isinstance(node, ast.FunctionDef):\n                    func_info = extract_function_info_from_diff(\n                        node, filepath, code_block\n                    )\n                    functions.append(func_info)\n        except SyntaxError:\n            # Code block might be incomplete, skip it\n            continue\n\n    return functions", "input": [{"id": "project_service.py:parse_diff_output:192:arg:0", "argument_name": "diff_output", "argument_type": "str"}], "output_type": "List[Function]", "file": "project_service.py"}]}